// Source: http://cpp-reference.ru/patterns/behavioral-patterns/iterator/

/*

 Составной объект, такой как список, должен предоставлять способ доступа к его элементам без
 раскрытия своей внутренней структуры. Более того, иногда нужно перебирать элементы списка
 различными способами, в зависимости от конкретной задачи. Но вы, вероятно, не хотите раздувать
 интерфейс списка операциями для различных обходов, даже если они необходимы. Кроме того, иногда
 нужно иметь несколько активных обходов одного списка одновременно. Было бы хорошо иметь единый
 интерфейс для обхода разных типов составных объектов (т.е. полиморфная итерация).

 Абстракция Iterator имеет основополагающее значение для технологии, называемой "обобщенное
 программирование". Эта технология четко разделяет такие понятия как "алгоритм" и "структура
 данных". Мотивирующие факторы: способствование компонентной разработке, повышение
 производительности и снижение расходов на управление.

 Назначение паттерна Iterator
    - Предоставляет способ последовательного доступа ко всем элементам составного объекта,
    не раскрывая его внутреннего представления.
    - Абстракция в стандартных библиотеках C++ и Java, позволяющая разделить классы коллекций и
    алгоритмов.
    - Придает обходу коллекции "объектно-ориентированный статус".
    - Полиморфный обход.
*/

// example

#include <iostream>
using namespace std;

class Stack
{
    int items[10];
    int sp;
public:
    friend class StackIter;
    Stack()
    {
        sp =  - 1;
    }
    void push(int in)
    {
        items[++sp] = in;
    }
    int pop()
    {
        return items[sp--];
    }
    bool isEmpty()
    {
        return (sp ==  - 1);
    }
};

class StackIter
{
    const Stack &stk;
    int index;
public:
    StackIter(const Stack &s): stk(s)
    {
        index = 0;
    }
    void operator++()
    {
        index++;
    }
    bool operator()()
    {
        return index != stk.sp + 1;
    }
    int operator *()
    {
        return stk.items[index];
    }
};

bool operator == (const Stack &l, const Stack &r)
{
    StackIter itl(l), itr(r);
    for (; itl(); ++itl, ++itr)
        if (*itl !=  *itr)
            break;
    return !itl() && !itr();
}

int main()
{
    Stack s1;
    int i;
    for (i = 1; i < 5; i++)
        s1.push(i);
    Stack s2(s1), s3(s1), s4(s1), s5(s1);
    s3.pop();
    s5.pop();
    s4.push(2);
    s5.push(9);
    cout << "1 == 2 is " << (s1 == s2) << endl;
    cout << "1 == 3 is " << (s1 == s3) << endl;
    cout << "1 == 4 is " << (s1 == s4) << endl;
    cout << "1 == 5 is " << (s1 == s5) << endl;
}
