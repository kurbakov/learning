// Source: http://cpp-reference.ru/patterns/structural-patterns/proxy/

/*
 Назначение паттерна Proxy

    - Паттерн Proxy является суррогатом или замеcтителем другого объекта и 
    контролирует доступ к нему.
    - Предоставляя дополнительный уровень косвенности при доступе к объекту, 
    может применяться для поддержки распределенного, управляемого или 
    интеллектуального доступа.
    - Являясь "оберткой" реального компонента, защищает его от излишней сложности.

 Существует четыре ситуации, когда можно использовать паттерн Proxy:

    - Виртуальный proxy является заместителем объектов, создание которых обходится 
    дорого. Реальный объект создается только при первом запросе/доступе клиента к 
    объекту.
    - Удаленный proxy предоставляет локального представителя для объекта, который 
    находится в другом адресном пространстве ("заглушки" в RPC и CORBA).
    - Защитный proxy контролирует доступ к основному объекту. "Суррогатный" объект 
    предоставляет доступ к реальному объекту, только вызывающий объект имеет 
    соответствующие права.
    - Интеллектуальный proxy выполняет дополнительные действия при доступе к объекту.

 Вот типичные области применения интеллектуальных proxy:

    - Подсчет числа ссылок на реальный объект. При отсутствии ссылок память под 
    объект автоматически освобождается (известен также как интеллектуальный указатель 
    или smart pointer).
    - Загрузка объекта в память при первом обращении к нему.
    - Установка запрета на изменение реального объекта при обращении к нему других 
    объектов.
*/

#include "iostream"

class RealImage
{
    int m_id;
public:
    RealImage(int i)
    {
        m_id = i;
        std::cout << "   $$ ctor: " << m_id << '\n';
    }
    ~RealImage()
    {
        std::cout << "   dtor: " << m_id << '\n';
    }
    void draw()
    {
        std::cout << "   drawing image " << m_id << '\n';
    }
};

// 1. Класс-обертка с "дополнительным уровнем косвенности"
class Image
{
    // 2. Класс-обертка содержит указатель на реальный класс
    RealImage *m_the_real_thing;
    int m_id;
    static int s_next;
public:
    Image()
    {
        m_id = s_next++;
        // 3. Инициализируется нулевым значением
        m_the_real_thing = 0;
    }
    ~Image()
    {
        delete m_the_real_thing;
    }
    void draw()
    {
        // 4. Реальный объект создается при поступлении
        //    запроса "на первом использовании"
        if (!m_the_real_thing)
            m_the_real_thing = new RealImage(m_id);
        // 5. Запрос всегда делегируется реальному объекту
        m_the_real_thing->draw();
    }
};
int Image::s_next = 1;

int main()
{
    Image images[5];

    for (int i; true;)
    {
        std::cout << "Exit[0], Image[1-5]: ";
        std::cin >> i;
        if (i == 0)
            break;
        images[i - 1].draw();
    }
}
