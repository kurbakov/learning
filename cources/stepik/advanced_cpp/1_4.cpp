/*
Напишите на языке C / C++ программу поиска максимальной по длине монотонно неубывающей подпоследовательности во входной 
последовательности вещественных чисел. Если таких подпоследовательностей несколько, выведите первую из них (найденную при 
просмотре входного потока первой). Подпоследовательностью считается цепочка чисел как минимум из двух элементов.

Примечание: искомая подпоследовательность является «плотной», в ней нет разрывов и посторонних элементов, включая числовые 
значения.

Вход: одно целое N (длина последовательности; возможно, со знаком «плюс»), за которым следует k вещественных чисел в любой 
разрешенной форме записи (и, возможно, символ «перевод строки» /n). Если k = N, анализируется входная последовательность 
вещественных целиком; если k > N, анализируется только N первых (расположенных в традиционной записи слева) членов этой 
последовательности. Если k < N (возможно, k = 0) или N < 2, входная последовательность некорректна.

Выход: два целых (натуральных), первое из которых L соответствует длине, а второе — порядковому номеру i первого элемента 
найденной подпоследовательности (принять i = 1, 2, 3, ...). Если входная последовательность корректна, но искомая 
подпоследовательность не обнаружена, вывести символ 0 (ноль). Во всех случаях подачи на вход некорректных, в том числе 
символьных / строковых данных, вывести строку [error] (вместе с квадратными скобками). В любом случае, программа должна 
завершаться с кодом 0 (EXIT_SUCCESS), остальные коды возврата будут восприниматься как ошибка.

N.B. Особое внимание нужно уделить проверке формата входных данных. Изучите особенности считывания из входного потока 
данных, не соответствующих ожидаемому формату, очень пригодится.

Sample Input:
7 1 2 3 4 5 6 7
Sample Output:
7 1
*/

#include <iostream>
#include <sstream>
#include <iterator>
#include <vector>
#include <cmath>

std::vector<std::string> get_data(){

    std::string input;
    std::getline (std::cin, input);

    std::istringstream buf(input);
    std::istream_iterator<std::string> beg(buf), end;

    std::vector<std::string> tokens(beg, end);

    return tokens;
}


int main(int argc, char const *argv[])
{
    std::vector<std::string> input = get_data();

    // ===================================================================== //
    // step 1: get N
    double N;
    unsigned long k_size = input.size()-1;

    try
    {
        N = std::stod(input[0]);
    }
    catch (...)
    {
        std::cout << "[error]" << "\n";
        return 0;
    }

    // одно целое N
    if(N - llround(N) > 0.0)
    {
        std::cout << "[error]" << "\n";
        return 0;
    }

    // Если k < N (возможно, k = 0) или N < 2, входная последовательность некорректна.
    if(k_size < N || k_size == 0 || N < 2)
    {
        std::cout << "[error]" << "\n";
        return 0;
    }

    // если k > N, анализируется только N первых (расположенных в традиционной записи слева)
    // членов этой последовательности
    if(k_size>N)
    {
        k_size=N;
    }
    // N is done!
    // ===================================================================== //

    // ===================================================================== //
    // step 2: get vector of k

    // за которым следует k вещественных чисел в любой разрешенной форме записи
    std::vector<double> k;
    double temp;
    for (unsigned int i=1; i<k_size+1; i++)
    {
        try
        {
            temp = std::stod(input[i]);
        }
        catch (...)
        {
            std::cout << "[error]" << "\n";
            return 0;
        }

        k.push_back(temp);
    }
    // k is ready
    // ===================================================================== //

    int start = 0;
    int L = 0; // max_length

    int temp_l = 0;

    // ... find max length ... //
    for(unsigned int i = 0; i<k.size()-1; i++)
    {
        for(unsigned int j=i+1; j<k.size(); j++)
        {
            if(k[j]>=k[j-1])
                temp_l++;
            else
                break;
        }
        if(temp_l > L)
        {
            start = i;
            L = temp_l;
        }

        temp_l = 0;

    }

    // Если входная последовательность корректна, но искомая подпоследовательность не обнаружена,
    // вывести символ 0 (ноль)
    if(L == 0)
    {
        std::cout << 0 << "\n";
    }
    else
    {
        std::cout << L+1 << " " << start+1 << "\n";
    }

    return 0;
}
